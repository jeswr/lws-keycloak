# LWS: Authorization

# Linked Web Storage (LWS): Authorization

## Abstract

Linked Web Storage describes a mechanism for persisting and managing protected data on the Web. Authorization is the mechanism by which agents request and present access tokens in order to access this protected data.

## 1\. Introduction

\[non-normative\]

Primary goals:

* Align with existing specifications (oauth2)  
* Consistent protocol flow for clients  
* **AS attests subject credential (or other credential types)**  
* **AS subject, rp (or derived values)**  
* **AS may make attestation about the actions a holder of this token can make when interacting with a RS**  
  * **RP is saying: I plan to go to RS and perform these actions (...)**  
  * **AS responds with either: yes, these actions are ok**  
  * **OR AS responds with deferred policy evaluation**  
* AS creates access token for use with Storage

\[TODO...\]

## 2\. Terminology

The terms "authorization server", "resource server", "access token", and "client" are defined by The OAuth 2.0 Authorization Framework \[RFC6749\].

The term "end-user credential" is defined by LWS Authentication \[LWS AuthN\]

## 3\. Roles

The roles in LWS authentication are the same as those defined by OAuth 2.0 Section 1.1 \[RFC6749\]. A storage server is a type of resource server that also conforms to the LWS storage specification.

## 4\. Protocol Flow

This specification describes the interaction between a client and an authorization server as well as the interaction between a client and a conforming storage server.

The interaction between the authorization server and the storage server is out of scope of this specification. The authorization server may be the same server as the storage server or it may be a separate entity.

### 4.1. Authorization Server Discovery

All protected resources managed by a storage server require a valid access token, generated by a trusted authorization server. A client can discover the location of a trusted authorization server by making an unauthorized HTTP request to a protected resource.

A storage server generating a 401 (Unauthorized) response MUST send a `WWW-Authenticate` header field containing at least one conforming challenge. A conforming challenge will include the parameters described below:

`as_uri` REQUIRED \- The value of this parameter is an absolute URI identifying the authorization server where a client can retrieve an access token. The value of this parameter will be the same as the `iss` claim of a valid access token.  
`realm` REQUIRED \- The value of this parameter is an absolute URI indicating the scope of protection. This value will be included in the audience (`aud`) claim of an access token. A client MUST verify that the URI of the originating request is logically contained within the `realm` presented in this response.  
`storage_metadata` RECOMMENDED \- The value of this parameter is an absolute URI that identifies an LWS storage metadata document \[LWS\_STORAGE\_SPEC\_REFERENCE\]

Other parameters MAY be included.

```

HTTP/2 401 Unauthorized
WWW-Authenticate: Bearer as_uri="https://authorization.example",
                realm="https://storage.example/storage_1",
                storage_metadata="https://storage.example/storage_1/metadata",
                error="invalid_token"
```

The storage server manages the canonical value for the as\_uri.  
Non normative note: For LWS implementations where lws:containment conforms with URI containment the `realm` will typically be an lws:StorageRoot. If multiple storages are hosted by a single software instance, the `realm` may include those multiple storages.

### 4.2. Authorization Server Metadata

An authorization server MUST provide a metadata resource to allow clients to discover endpoint locations and capabilities as described in RFC8414. This metadata resource MUST be available at a URL with the path `/.well-known/lws-configuration`.

An authorization server SHOULD advertise the subject tokens that it supports by including a `subject_token_types_supported` entry in the server metadata document. This entry is a JSON array containing a list of valid `subject_token_type` values that can be supplied at the authorization server's token endpoint.

```javascript
{
    "issuer": "https://authorization.example",
    "grant_types_supported": [
        "urn:ietf:params:oauth:grant-type:token-exchange"],
    "token_endpoint": "https://authorization.example/token",
    "jwks_uri": "https://authorization.example/jwks",
    "claims_supported": [
        "sub",
        "iss",
        "client_id",
        "aud"],
    "response_types_supported": [
        "token"],
    "subject_token_types_supported": [
        "urn:ietf:params:oauth:token-type:jwt",
        "urn:ietf:params:oauth:token-type:id-token"]
}
```

### 4.3. Token Exchange

An LWS authorization server is a conforming OAuth 2.0 authorization server, capable of issuing access tokens to a client for use with a storage server. In order to issue an access token, a client must first present a valid subject token, such as an end-user credential, to the authorization server via OAuth 2.0 Token Exchange \[RFC8693\].

#### 4.3.1 Request

The authorization server's token endpoint MUST support the `urn:ietf:params:oauth:grant-type:token-exchange` grant type, as described in OAuth 2.0 Token Exchange \[RFC8693\].

When performing the token exchange grant type, the following additional requirements apply:   
The `resource` parameter is REQUIRED. The value of this parameter MUST be an absolute URI and will be used to populate the `aud` (audience) claim in the resulting access token. The supplied value will be the same as the `realm` parameter response in a WWW-Authenticate challenge. The authorization server MUST reject any request in which the `resource` parameter identifies an unknown or untrusted storage.

The `subject_token` parameter is REQUIRED. The value of this parameter MUST include a valid subject token, such as an end-user credential.

Before returning an access token to the client, the authorization server MUST successfully validate all presented tokens.

Non-normative example of a token request (the `subject_token` parameter has been truncated).

```
POST /token HTTP/1.1
 Host: authorization.example
 Content-Type: application/x-www-form-urlencoded

 grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange
 &resource=https%3A%2F%2Fstorage.example%2Fstorage_1
 &subject_token=eyJ0eXAiOiJhcytqd3QiLCJhbGciO...fiK51VwhsxJ-siBMR-YFiA
 &subject_token_type=urn%3Aietf%3Aparams%3Aoauth%3Atoken-type%3Aid_token
```

#### 4.3.2 Response

If the token request is valid and the client is authorized to make the request, the authorization server response MUST conform to Section 5.1 from the OAuth 2.0 Authorization Framework \[RFC6749\]. The resulting access token MUST conform to the JSON Web Token Profile for OAuth 2.0 Access Tokens \[RFC9068\].

In addition, the access token must meet the following requirements:

* `sub` (subject) \- REQUIRED. This claim MUST be an absolute URI identifying the agent performing the operation  
* `iss` (issuer) \- REQUIRED. This claim MUST be the absolute URI of the authorization server  
* `client_id` (client id) \- REQUIRED. This claim MUST be an absolute URI identifying the client.  
* `aud` (audience) \- REQUIRED. This claim MUST include the absolute URI supplied by the client in the `resource` parameter. This value will be used to restrict the entities for which the access token is valid.  
* `exp` (expiration) \- REQUIRED. Authorization servers SHOULD issue tokens with short lifetimes (RECOMMENDED: 300 seconds or less) to limit exposure from token theft  
* `iat` (issued at) \- REQUIRED.   
* `jti` (JWT ID) \- REQUIRED.

Non-normative example of a successful token response

```
HTTP/1.1 200 OK
Content-Type: application/json

{
    "access_token":"eyJ0eXAiOiJhcytqd3QiLCJhbGciOiJFUzI1NiIs...DeWt4QuZXso",
    "token_type":"Bearer",
    "expires_in":3600
}
```

All invalid or unauthorized requests MUST result in an error response as described in Section 5.2 in The OAuth 2.0 Authorization Framework \[RFC6749\].

Non-normative example of an error response

```
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
    "error":"invalid_request"
}
```

#### 4.3.3 Example access token

Below is a non-normative example of an access token issued by an authorization server.

```
{
  "kid": "ec51c6b2",
  "kty": "EC",
  "alg": "ES256",
  "crv": "P-256",
  "typ": "at+jwt"
}
.
{
  "sub": "https://id.example/agent",
  "iss": "https://authorization.example",
  "client_id": "https://app.example/id",
  "aud": "https://storage.example",
  "exp": 1735686300,
  "iat": 1735686000,
  "jti": "550e8400-e29b-41d4-a716-446655440000"
}
.
signature
```

### 4.4. Token Validation by a Storage Server

Once a client is in possession of an access token, it will present this token to a storage server. The storage server is responsible for verifying this token before performing any operation.

#### 4.4.1 Presentation

A client MUST present an access token to a storage server using the `Authorization` header with an authentication scheme as defined in \[RFC6750\].

```shell
Authorization: Bearer eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### 4.4.2 Validation

A storage server MUST validate an access token by performing the following checks in order, rejecting the request upon any failure:

1. JWT Signature Validation: Verify the JWT signature using the authorization server's public key retrieved from the `jwks_uri` specified in the authorization server metadata. Storage servers SHOULD cache these keys but MUST support key rotation.  
2. Issuer Validation: Verify the `iss` claim matches the expected authorization server identifier.  
3. Audience Validation: Verify the `aud` claim contains exactly one value \- and this value is an absolute URI which logically contains the target resource.   
4. Temporal Validation, subject to an allowable clock skew between systems.  
   1. Verify the current time is before the `exp` (expiration) claim   
   2. Verify the current time is not before the `nbf` (not before) claim, if present  
   3. Verify that the `iat` (issued at) claim is not in the future

If validation fails, the storage server MUST return 401 Unauthorized with a `WWW-Authenticate` header containing an appropriate error parameter (e.g., invalid\_token, invalid\_request, or insufficient\_scope).

If the token is valid but does not allow the requested operation, the storage server MUST reject the operation.

## 5\. Implementation Guidance

RPs SHOULD cache authorisation tokens after they have been used to access a protected resource. When accessing any further resources contained that are logically contained by the `aud` of the token, then the token should be used proactively to perform authenticated fetches on the resources.

RPs SHOULD refresh authorisation tokens if resources logically contained by the `aud` of the token have been recently accessed.

## 6\. Privacy Considerations

* Minimal Disclosure: Authorization servers SHOULD issue tokens containing only information necessary for authorization. Avoid including sensitive subject attributes unless required.  
* Logging: Implementations SHOULD NOT log full token contents. If logging is necessary, tokens should be truncated or hashed.

### 6.1 Linkability of pseudonomous identiiers

When using pseudonomous identifiers in JWTs, client applications should request a batch issuance of JWTs and use each one time only against the storage server. This prevents the storage server from being able to use pseudonomous identifers from correlating requests.

This does not prevent the storage server from using other information such as similarities in JWT content (e.g. policies), and originating IP address to correlate requests.

When using pseudonomous identifiers, the authorisaiton server should not issue the same pseudonomous identifier more than once.

## 7\. Security Considerations

The recommendations described in Best Current Practice for OAuth 2.0 Security \[RFC9700\] apply to this specification.

### 7.1 Transport Security

All AS implementations MUST support TLS.  Which version(s) ought to be implemented will vary over time and depend on the widespread deployment and known security vulnerabilities at the time of implementation. When using TLS, the client MUST perform a TLS/SSL server certificate check, per RFC 6125 \[RFC6125\]. Implementation security considerations can be found in "Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)" \[BCP195\].

### 7.2 Token Security

Bearer Token Vulnerabilities: Bearer tokens are vulnerable to theft and replay. Required mitigations:

* Short Lifetimes: Tokens SHOULD have lifetimes of 300 seconds (5 minutes) or less  
* Audience Binding: Tokens MUST be bound to a specific storage server via the `aud` claim  
* Secure Storage: Clients MUST store tokens securely in memory when possible, never in localStorage, URLs, or logs

### 7.3 End-User Credential Protection

End-user credentials with unrestricted audiences MUST NOT be provided to untrusted authorization servers.

In an end-user credential issuer is unable to restrict the audience of a token, clients SHOULD use a mechanism such as OAuth 2.0 Token Exchange \[RFC8693\] to create audience-restricted credentials before interacting with authorization servers.

### 7.4 Token Validation

Storage servers MUST:

* Verify JWT signatures using the authorization server's public key  
* Validate all claims: `iss`, `aud`, `exp`, `iat`, `jti`  
* Reject the `none` algorithm and verify the `alg` header matches expected algorithms  
* Use minimal clock skew tolerance (RECOMMENDED: 60 seconds maximum)  
* Implement `jti` caching for replay prevention, with size limits to prevent DoS

### 7.5 Authorization Enforcement

### 7.5.1 Preventing replay attacks

If a RS has different software instances for different storages, individual storage instances SHOULD NOT accept authorisation tokens with an aud claim scoped outside the current storage \- in order to prevent replay attacks between malicious tenants. For example if [storage.example/a](http://storage.ex/a) and [storage.example/b](http://storage.ex/b) are different tenants, then an authorization token with an aud claim of [storage.example/](http://storage.ex/a) SHOULD NOT validate on resources in [storage.example/a](http://storage.ex/a) or [storage.example/b](http://storage.ex/b).

When an RP receives a 401 from an RS, the RP MUST validate that value for realm in the  WWW-Authenticate header is an absolute URI logically contains the target resource \- before using this value to request an authorisation token from the Authorisation Server.

ASs MUST include exactly one value in its aud claims.

RPs MUST NOT make authenticated requests to an RS using an authorisation token containing more than more than one aud value.

RPs MUST NOT make authenticated requests to a resource that is not logically contained in the aud value.

~~Path Traversal: Storage servers MUST reject requests containing path traversal sequences (`..`, `%2e%2e`, etc.) before matching against `locations`.~~

Precise Matching: Carefully validate container-based authorization. Ensure HTTP methods correctly map to required actions (GET→Read, PUT→Update, POST→Create, DELETE→Delete).

RPs SHOULD NOT share an authorisation token with any service other than the RS which is the subject of the aud claims. 

### 7.6 Input Validation

Implementations MUST validate:

* URI formats and schemes (reject malformed URIs, only allow expected schemes)  
* String lengths to prevent buffer overflows  
* Reject tokens with `exp` more than 1 hour in the future

### 7.7 Authorization Server Trust

Storage servers SHOULD maintain an explicit allowlist of trusted authorization server issuers and reject tokens from unknown issuers. Malicious authorization servers could issue excessive permissions, log credentials, or refuse revocation.

### 7.8 Token Leakage Prevention

Tokens MUST NOT be:

* Included in URLs (vulnerable to referrer headers, browser history, logs)  
* Stored in localStorage/sessionStorage (vulnerable to XSS)  
* Logged in error messages or server logs  
* Accessible to untrusted client-side scripts

### 7.9 CORS Support

If storage servers support CORS, validate `Origin` headers and use restrictive `Access-Control-Allow-Origin` values.

### 7.10 Proactive authorization

### RPs SHOULD NOT proactively fetch new authorisation tokens from the AS before having received a 401 response from an RS.  This prevents a malicious RS (e.g. [storage.example](https://storage.example/)/mal) and AS (e.g. mal.authz) from colluding to have the RS specify a realm that is broader than their own scope (e.g. storage.example/) with the AS as the authorisation server \- and then discovering that an RP is attempting to access another RS (e.g. storage.example/good) within that scope when the authorisation token is proactively fetched from the malicious AS.

### 7.11 Clock Skew

A maximum of 60 seconds clock skew is RECOMMENDED.

### 7.12 HTTP Response codes on forbidden operations

If an end-user attempts to access a resource using a valid JWT, and is not authorised to perform any operations on the requested resource, then the storage server SHOULD produce a 404 response so as to avoid revealing the existence of a resource. If the end-user does have access to perform some operations on the requested resource, but is not permitted to perform the current operation, the storage server SHOULD produce a 403 forbidden.

### 8\. IANA Considerations

### 8.1 well-known URI Registry

This specification registers the well-known URI defined in Section XX in the IANA "Well-Known URIs" registry \[IANA.well-known\] established by RFC 5785 \[RFC5785\].

* URI suffix: lws-configuration  
* Change controller: W3C  
* Specification document: Section XX of LWS-Auth  
* Related information: (none)

### 8.2 OAuth Authorization Server Metadata Registry

This specification adds the following value to the "OAuth Authorization Server Metadata" registry \[IANA.OAuth.Parameters\] established by \[RFC8414\].

* Metadata Name: token\_subject\_types\_supported  
* Metadata Description: JSON array containing a list of the OAuth 2.0 "token\_subject\_type" values that this authorization server supports  
* Change Controller: W3C  
* Specification Document(s): Section XX of LWS-Auth

# LWS: Storage

### 4.X. Storage Server Metadata

The storage server identifier should be sufficient for a client to discover additional metadata about the storage server, such as its capabilities and the location of endpoints.

Unless the scheme provided in the `WWW-Authencate` header requires otherwise, the storage server MUST provide a metadata resource at a URL with the path `/.well-known/lws-storage-server`. The response MUST be a document with content type application/ld+json which conforms to the following schema

```javascript
{
    "as_uri": string | undefined,

    // Everything below here is has not yet been discussed

    // Discovery of resource notifications endpoint
    "notifications_endpoint": string | undefined,

    // Alternatively could be required that this is always available at
    // /.well-known/lws-storage-cid
    "cid": "/.well-known/lws-storage-cid"
}
```

### 4.X. CRUD operation mapping

TODO

| GET | READ |
| :---- | :---- |
| OPTIONS | READ |
| HEAD | READ |
| PUT | WRITE if resource exists. CREATE if resource does not. |
| PATCH | WRITE | APPEND if resource exists. CREATE if resource does not. |

Precise Matching: Carefully validate container-based authorization. Ensure HTTP methods correctly map to required actions (GET→Read, PUT→Update, POST→Create, DELETE→Delete).

## 8.2 Usage Controls

Resource server implementations may use policy languages which include statements for usage controls which are not server-side enforceable.

Clients can request that usage controls can be included in the HTTP response on a resource as follows

```shell
GET /resourcePreference-Applied: usage-controls=inline; format=application/ld+json; profile="https://schema.example.com/usage-controls/v1"
```

Clients can request that servers enforce usage controls on their behalf as follows

```shell
GET /resourceUsage: {
   "@context": "http://www.w3.org/ns/odrl.jsonld",
   "@type": "/* REQUEST? */",
   "uid": "http://example.com/policy:1011",
   "profile": "http://example.com/odrl:profile:06",
   "permission": [{
           "target": "http://example.com/resource",
           "assigner": "http://example.com/org:abc",
           "action": "play"
    }]

}
```

Servers MUST reject the request as unauthorized if they do not support server side enforcement.

 Servers MUST reject the request as unauthorised if the requested policy is not permitted after policy evaluation.

Deprecated Text

In this case, resource servers SHOULD provide a mechanism for discovering the usage controls that apply to a resource, and MAY provide a service for performing usage policy evaluation on behalf of clients.

The client should 

Usage controls SHOULD be discoverable as a Link Header with the rel value set to termsOfUse.

```shell
Link: <https://storage.example/photos.odrl>; rel="termsOfUse"
```

The response of an authenticated request to the termsOfUse resource, MUST be the set of policies that apply for the authenticated entity on the given resource.

Usage control policy evaluation SHOULD be supported by having clients POST data from

```shell
Link: <https://storage.example/photos.odrl>; rel="termsOfUse"
```

Link: \<...\>; rel="termsOfUse" (or some other rel value)

* this will NOT be part of LWS; instead, this (and any sort of DRM policy structure) will be something that an implementation can build atop LWS

# Non-normative notes

“An authorization server SHOULD advertise the supported Authentication Suites” \- why “SHOULD” rather than “MUST”.

- Privacy considerations \- a user self-hosting may not want to advertise that they use SSI, or a more bespoke authentication method for themselves  
- This is a bespoke parameter that we have created. Therefore some frameworks may have difficulty implementing it.

# Copied from other areas

 ~~The subject of the identity credential MUST be used as the subject of the access token created by the authorization server. In addition, the client identifier from the identity credential MUST be used as a client identifier in the new access token.~~

### ~~4.4. Authorization Request~~

~~When a client requests an access token from an authorization server, it MUST use the `authorization_details` token request parameter to specify the authorization details it wants the authorization server to assign to an access token. In addition to the requirements outlined in OAuth 2.0 Rich Authorization Requests \[RFC9396\], a conforming `authorization_details` request parameter MUST adhere to the following:~~

~~An authorization requirement object MUST have a `type` field whose value equals `https://www.w3.org/ns/lws#AuthorizationRequest`.~~

~~The `locations` field is a REQUIRED array of absolute URIs which MUST contain one or more resource identifiers from a storage. These values constrain an access token to resources at particular locations.~~

~~The `actions` field is a REQUIRED array which MUST contain one or more allowable operations from the set: `Read`, `Update`, `Create`, and `Delete`. These values constrain an access token to particular HTTP operations.~~

~~Below is an example authorization request~~

```javascript
[
  {
    "type": "https://www.w3.org/ns/lws#AuthorizationRequest",
    "locations": [ "https://storage.example/photos" ],
    "actions": [ "Read", "Create" ],
  }
]
```

~~The `authorization_details` parameter is REQUIRED. The value of this parameter MUST conform to OAuth 2.0 Rich Authorization Requests section 2\. All `location` values MUST be managed by the storage identified in the `resource` parameter. The value of this parameter MUST be included in any resulting access token.~~

Token validation

1. ~~Single-Use Enforcement: Storage servers MUST implement replay protection using the jti claim:~~  
   1. ~~Maintain a cache of used jti values until their associated tokens expire~~  
   2. ~~Reject any token whose jti has been previously used~~  
   3. ~~The cache MAY be distributed across multiple server instances~~  
2. ~~Authorization Details Validation: Verify the request is permitted by at least one entry in the authorization\_details array (see next section 4.6.4)~~

Specific to LWS

* The `authorization_details` claim MUST be present and contain at least one authorization object 

#### ~~4.6.4 Authorization~~

~~The storage server MUST verify that at least one authorization object in the authorization\_details array permits the incoming HTTP request. An authorization object permits a request if ALL of the following are true:~~

1. ~~Type: The type field equals `https://www.w3.org/ns/lws#AuthorizationRequest`~~  
2. ~~Location: The requested resource URI matches one of the `locations` entries. Before matching, the storage server MUST normalize all URIs.~~  
   1. ~~Exact URI match, OR~~  
   2. ~~A location entry identifies a container in which the requested resource appears.~~  
3. ~~Action: The HTTP method corresponds to a listed action:~~  
   1. ~~GET and HEAD require `Read`~~  
   2. ~~PUT requires `Update`~~  
   3. ~~POST requires `Create`~~  
   4. ~~DELETE requires `Delete`~~

~~If no authorization object satisfies all conditions, the request MUST be rejected with 403 Forbidden.~~